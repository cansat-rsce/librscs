#ifndef RSCS_DS18B20_H_
#define RSCS_DS18B20_H_

/*	Модуль-драйвер датчика температуры ds18b20
	Даташит: http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf
	он же на русском: http://labkit.ru/userfiles/file/documentation/Sensor/DS18B20_RU.pdf
 */

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#include "error.h"

// дескриптор датчика
struct rscs_ds18b20_t;
typedef struct rscs_ds18b20_t rscs_ds18b20_t;

// Начало работы с датчиком - создание дескриптора
/* Параметр sensor_uid - уникальный идентификатор датчика на шине ONEWIRE
	Если указать его равным 0x00 - модуль будет работать с датчиком на шине
	(подразумевается, что он один) не используя адресацию, при помощи команды ONEWIRE_SKIP_ADDR
	в случае ошибки возвращает NULL */
rscs_ds18b20_t * rscs_ds18b20_init(uint64_t sensor_uid);

// Завершение работы с датчиком - удаление дескриптора
void rscs_ds18b20_deinit(rscs_ds18b20_t * sensor);

// Передает датчику коанду на начало замера температуры
/*	чтение температуры процесс длительный и длится порядка секунды на настройках максимальной точности
	функция не ожидает окончания измерения - это лишь команда на начало замера
	если датчик не ответил импульсом присутсвия, возвращает код ошибки RSCS_E_NODEVICE */
rscs_e rscs_ds18b20_start_conversion(rscs_ds18b20_t * sensor);

/*Проверка окончания вычисления температуры датчиком.
 * Функция считывает текущее состояние шины.
 * Если значение равно нулю, то в данный момент датчик замеряет температуру.
 * Если значение равно единице, то к данному моменту датчик закончил работу с температурой и можно забирать полученное значение.
 * Причем функция использует для считывания состояния исключительно протокол one_wire.
 * Функцию можно использовать только после rscs_ds18b20_start_conversion,
 * причем между ними не должно быть никаких других взаимодействий по one_wire*/
bool rscs_ds18b20_check_ready(void);

// Получение результатов измерения
/*	Параметры
	- sensor - дескриптор сенсора
	- value_buffer - буффер, в который будет помещенно прочитанное из дачтика сырое значение

	Это сырое значение старшего и младшего байт из "оперативной памяти" дачтика
	То, каким образом следует переводить этот значение в градусы цельсия зависит от конфигурации датчика
	и подробно расписано в даташите.

	Если на шине никто не ответил импульсом присутсвия - возвращает код ошибки RSCS_E_NODEVICE
	Если контрольная сумма сообщения, полученного от датчика не сошлась - возвращает код ошибки RSCS_E_CHKSUM */
rscs_e rscs_ds18b20_read_temperature(rscs_ds18b20_t * sensor, int16_t * value_buffer);

// Функция для конвертирования сырого значения температуры, получаемого с ds18b20, в градусы цельсия.
float rscs_ds18b20_count_temperature(rscs_ds18b20_t * sensor, int16_t raw_value);

#endif /* RSCS_DS18B20_H_ */
